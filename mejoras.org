* Mejoras al Soft del MotherBoard principal para nuevo soft Raspberry
** DONE Empiezo docs de cambios
   CLOSED: [2018-09-13 Thu 18:28]
** DONE Empiezo nuevas funcionalidades
   CLOSED: [2018-09-21 Fri 16:12]


** TODO Enviar 4 strings al booteo del equipo
** TODO Enviar con cada nueva conexion de antena los 4 strings de canales
** TODO Achicar tiempo entre conexion y deteccion de falla para las antenas
** TODO Avisar de la desconexion de un canal
** TODO Agregar codigo de Hardware de MotherBoard
   - pag 1073 Unique device ID

** TODO Nuevo Modulo para Antenas / y funciones del Viejo
*** En arranque - VIEJO -
    - en el arranque las antenas se revisan con la nueva funcion UpdateAntennaState()
    - pero no da bola a las respuestas mas que cargar el string de antX
    
*** Antes de empezar un tratamiento - VIEJO -
    - se revisa nuevamente las antenas conectadas justo antes de calcular seniales
    - se pregunta por el string desde Session_Channel_X con el comando get_params de la funcion
      Session_Channel_1_Verify_Antenna(* session)    
    - luego arranca Warming_Up Plateau Cooling_Down
    - el estado de la antena lo sigue preguntando Session_Channel_X independiente del estado en que se encuentre

*** las antenas se revisan por un timer que depende de TIM7 (1ms) - VIEJO -
    - Signal_TIM1MS ()
      solo se revisan si la sesion no comenzo, sino las revisa el manager de la sesion en cada canal

*** si en el tratamiento se usa la pausa la comunicacion se cae - VIEJO -
    - tiene que ver con que Signal_TIM1MS () no descuenta el timer si esta en pausa
    - el canal Session_Channel_1() debe estar corriendo pero pausado con (session_ch_1.status == 1)
      la pausa hace que no se genere en ningun de los tres estados WMUP PLATEAU CDWN
    
*** con el modulo nuevo
    arm-none-eabi-size Magneto_GTK_rom.elf
    text    data     bss     dec     hex filename
    70624     112   24828   95564   1754c Magneto_GTK_rom.elf

*** Modulo nuevo en version 1.2 - NUEVO -
    - el nuevo modulo se comunica con las antenas y manda segun modo (keepalive, get_params, get_temp)
    - funciona en standby esperando parametros y enviado keepalive
    - cuando desde la sesion avisan que se pasa a tratamiento hace un lock de canales y pasa a treatment
    - en treatment pide get_temp, y actualiza el contador de keepalive (que no llegue a 0)
    - avisa a la sesion que la antena esta presente si tiene parametros y keepalive
    - cuando se termina el tratamiento pasa nuevamente a standby
    - no debera caer la comunicacion en pause
    - si se conecta una nueva antena se comunica pero no le manda tratamiento

*** comunicacion desde la placa de antena (ACTUAL PLACA ANTENA)
    - manda el mensaje de conexion 1 ves por segundo hasta estar conectada
    - pasa a conexion con cualquier mensaje valido desde el mother/magneto
    - si conecta, despues si no recibe nada a los 10 segs aprox lo vuelve a mandar
    - si esta conectada, no manda nada solo contesta lo que se le pregunta
    - en el codigo actual contesta a get_params get_temp keepalive


** Errores encontrados
   - arrancan 2 antenas quito 1 (no avisa) si a cambio en 5 segundos no ve la desconexion??
   - arranca con 1 la cambio de lugar y sigue


* Migrar a emacs y repositorio github atom -> emacs
** DONE Crear primero bin y revisar tamanios
   CLOSED: [2018-09-14 Fri 08:39]
   arm-none-eabi-size Magneto_GTK_rom.elf
   text    data     bss     dec     hex filename
  74984     112   25620  100716   1896c Magneto_GTK_rom.elf
   
** DONE Utilizar nuevo Makefile
   CLOSED: [2018-09-19 Wed 18:02]
   - usar global
   - cargar todos los archivos para flash de micro
   - utilizar configuracion del README de blue pill
   - revisar diferencias .gitignore
   - cambie cmsis_core OK

** DONE Quitar LibST de donde se pueda
   CLOSED: [2018-09-21 Fri 09:33]
   - usar emacs_arduino y emacs_stretcher_F103

*** para usar usart.c usart.h desde emacs_stretcher_F103
    - armo un modulo de comm para quitar el codigo de comunicaciones
      entre MotherBoard, PC y antennas del modulo uart y poder usar
      modulo nuevo
    - con el nuevo modulo mismo tamanio de codigo
    - con el cambio uart -> usart mejoro algo de codigo

*** con modulo usart ver los pines alternativos, son distintos segun hardware
*** DONE FALTA PROBAR ANTERIOR
    CLOSED: [2018-09-20 Thu 17:01]

*** DONE migro modulo timer
    CLOSED: [2018-09-17 Mon 19:42]
    - ojo hay un monton de pwm que no estan en este modulo
    - paso todas las funciones pwm al nuevomodulo timer, compila OK, genera OK
    - borro archivos modulo pwm

*** DONE Migro el modulo de clock general a startup_src
    CLOSED: [2018-09-17 Mon 15:14]
    - codigo antes
    arm-none-eabi-size Magneto_GTK_rom.elf
    text    data     bss     dec     hex filename
    73728     112   22916   96756   179f4 Magneto_GTK_rom.elf

    - agrego hard.h en src por las definiciones de clock, despues lo debo juntar con GTK_Hard.h
    - tambien quito dumb function SystemInit() del main (prototipo y definicion)

    - despues de implementar
    arm-none-eabi-size Magneto_GTK_rom.elf
    text    data     bss     dec     hex filename
    73144     112   22916   96172   177ac Magneto_GTK_rom.elf
    
    - ahora pruebo de quitar rcc de libST pero no puedo porque el adc lo sigue usando
    - esta dificil porque en emacs_arduino y en emacs_stertcher no esta implementado el adc sin libST

*** migro modulo gpio que no estaba quitando los inits de las primeras funciones de main
    - quito Tamper_Config del GTK_Hard.c
    - quito stm32gpio del makefile OK

*** DONE No funciona nada!!!!
    CLOSED: [2018-09-17 Mon 15:13]
    - aparentemente se esta llamando dos veces a SystemInit() una desde el startup assembler
      y otra dentro de main

*** DONE no sale la libST
    CLOSED: [2018-09-19 Wed 18:00]
    stm32f10x_conf.h la pide stm32f10x.h con el STD_PERIPH_DRIVER desde el Makefile 
    para usar assert_params
    - la logre sacar, hay que probar todo

*** DONE flash_program tambien usa libST
    CLOSED: [2018-09-19 Wed 18:00]
    - la unica funcion de flash_program es FLASH_Program (se usa en el cmd save,)
    - el resto son funciones de GTK_Estructura (Channel_Load)
    - el comando load, llama a Session_Load de GTK_Estructura que a su vez llama readDataFromFlash

*** DONE Probar lo anterior - FLASH - !!!!
    CLOSED: [2018-09-20 Thu 13:02]
    - pruebo enviando comandos, pido grabar apago y prendo equipo y reviso si esta todo ok
    - parece que graba ok, pero cuando lee...
    - 3 duration OK
    - 2 signal NOK
    - 2 state_of_stage NOK

      PUEDE SER POR TAMANIO DEL BUFFER A LA PC???
**** graba bien muestra mal, aumento el tamanio del buffer de la PC
     - cambio tamanio de buffer a SIZEOF_PC_TXDATA y SIZEOF_PC_RXDATA
       en el envio de Usart1SendUnsigned y en USART1_IRQHandler
     - Ahora esta OK!
      
*** DONE migro modulo adc, le agrego dma
    CLOSED: [2018-09-19 Wed 17:08]
    - GTK_Signal usa Session_Current_Limit_control que llama al adc
    - como ahora va a ser por DMA lo debo corregir, lo dejo como pendiente
    - comentadolo compila ok
     
*** DONE Session_Current_Limit_control
    CLOSED: [2018-09-20 Thu 15:39]
    - le armo funciones de muestreo adc que se activan con USE_ADC_SAMPLE_BY_SAMPLE

** DONE Armar nuevos modelos de archivos en modulos
   CLOSED: [2018-09-21 Fri 11:32]
   - .h .c con nuevo modelo
   - arme modulo comms, mejore usart, de modulos base gpio y dma, mejore adc
   - falta ver si finalmente hago algo para antenas

** DONE Upgrade del repositorio remoto GitHub
   CLOSED: [2018-09-21 Fri 09:33]
   - pasar a emacs...


* Respecto del hardware Raspberry
** perdio el RTC
   - podria traer problemas de conexion original



* Respecto del software Raspberry
** Necesita red para arrancar
** En los primeros 20 seg de tratamiento no acepta STOP
** Barra desplazamiento frecuencia un poco mas grande (por el touch)
** Quitar entradas setup adicionales si no va a tener pantalla
*** Se frizo el boton de setup
*** Un para de veces entra a una pantalla blanca y queda ahí

** Necesitaria alguna pantalla de configuracion de red si no va a bootear

** Tocar varias veces la pantalla en la potencia pasa a pantalla blanca
*** DONE se filmo y envio video del problema
    CLOSED: [2018-09-21 Fri 16:11]


* Comunicaciones en general hasta hoy
** Preparar el tratamiento
   Terminar cada línea con "\r\n"
   incluir después de cada linea un timer de 100ms

*** Formato de paquete
    Duration (Duración de tratamiento)
    Timer 100ms
    Signal (Parámetros de forma de onda y frecuencia)
    Timer 100ms
    state_of_stage,1,1
    Timer 100ms
    save,01
    Timer 100ms

**** Ejemplo
    Tratamiento 15 minutos, onda cuadrada al 70%, 10Hz
    duration,00,15,00,1
    timer 100ms                                                                                                                   
    signal,070,070,0000,0001,0049,0001,0049,0000,0000,1
    timer 100ms
    state_of_stage,1,1
    timer 100ms
    save,01
    timer 100ms

*** #### luego de la carga un par de segundos (20s) y manda
    load,01                                                                                                                               
    start,

*** Duración del tratamiento
    Duraciones de tratamiento validas entre 5 y 120 minutos (2 horas)

    duration,hh,mm,00,1

    hh = horas (valido 00,01,02)
    mm = minutos (valido de 00 a 59)
    00 = Fijo (para futuras versiones)
    1 = Fijo (para futuras versiones)

**** Ejemplos 
    duration,00,15,00,1 – Duración 15 minutos
    duration,01,10,00,1 – Duración 70 minutos

*** Parámetros de forma de onda y potencia
    Actualmente disponibles triangular y cuadrada, senoidal por ahora tendría que estar gris (no disponible)
    signal,001,002,0003,0004,0005,0006,0007,0008,0009,1
    001 = Potencia en %1 (válido de 10 a 100)
    002 = Potencia en %2  (válido de 10 a 100) para futuras versiones, ahora repite el valor 001
    0003 = enviar todo en 0 “0000”
    0004 = Tiempo rampa ascendente en ms (válido de 0 a 100)
    0005 = Tiempo meseta en ms (válido de 0 a 100)
    0006 = Tiempo rampa descendente en ms (válido de 0 a 100)
    0007 = Tiempo de espera en ms (válido de 0 a 100)
    0008 = enviar todo en 0 “0000”
    0009 = enviar todo en 0 “0000”
    1 = Fijo (para futuras versiones)

**** Ejemplos
     signal,070,070,0000,0049,0001,0001,0049,0000,0000,1 - #Triangular 70% 10Hz
     signal,090,090,0000,0023,0001,0001,0025,0000,0000,1 - #Triangular 90% 20Hz
     signal,070,070,0000,0016,0001,0001,0015,0000,0000,1 - #Triangular 70% 30Hz
     signal,100,100,0000,0011,0001,0001,0013,0000,0000,1 - #Triangular 100% 40Hz
     signal,080,080,0000,0008,0001,0001,0010,0000,0000,1 - #Triangular 80% 50Hz
     signal,070,070,0000,0007,0001,0001,0007,0000,0000,1 - #Triangular 70% 60Hz

     signal,070,070,0000,0001,0049,0001,0049,0000,0000,1 - #Cuadrada 70% 10Hz
     signal,070,070,0000,0001,0023,0001,0025,0000,0000,1 - #Cuadrada 70% 20Hz
     signal,070,070,0000,0001,0016,0001,0015,0000,0000,1 - #Cuadrada 70% 30Hz 
     signal,070,070,0000,0001,0011,0001,0013,0000,0000,1 - #Cuadrada 70% 40Hz
     signal,070,070,0000,0001,0008,0001,0010,0000,0000,1 - #Cuadrada 70% 50Hz
     signal,070,070,0000,0001,0007,0001,0007,0000,0000,1 - #Cuadrada 70% 60Hz

*** ##### para pedir el número de serie de la placa generadora #####
    serial num
    #va a responder con un string de 12 caracteres
serial num (de placa 3)
0xff3356343735563443027122

*** #### la locación levantarla de un txt que se pueda editar dentro de la raspberry #####


** ##### durante el tratamiento la raspberry puede enviar:
  pause,1                 ;;pone el equipo en pausa debe detener el timer
  pause,0                 ;;continua el tratamiento
  
  stop,                      ;;detiene el tratamiento (lo termina) a 
  través del botón stop
  finish_ok,              ;;termina el tratamiento luego de pasado el 
  tiempo activa el buzzer interno

** Durante el tratamiento puede reportar uno o mas de los siguientes errores:

    //reporta errores como "ERROR(0xNNN)\r\n"
    //0x01N antena desconectada
    //0x02N antena perdida
    //0x04N sobre temperatura
    //0x05N sobre corriente
    //N num de canal 1-4

*** Pueden existir otros tipos de errores pero los previos son los mensajes importantes
    //errores adicionales "ERROR(0xNNN)\r\n"
    //0x11N error en la sesión
    //0x12N error en los parámetros de antena

    ##### errores con las antenas permiten seguir el tratamiento hasta que se produzcan errores en las 4 antenas.
    ##### Luego de cualquiera de lo errores por corriente termina el tratamiento por error #####
    cuando decide cortar por error, envía hacia la raspberry como mínimo dos mensajes de stop
    "STOP\r\n"
